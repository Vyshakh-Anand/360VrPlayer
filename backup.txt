const { ipcRenderer } = require('electron');
const THREE = require('three');
const fs = require('fs');
const path = require('path');

// Global variables
let scene, camera, renderer;
let sphere;
let videoElement, videoTexture;
let isPlaying = false;
let videoMode = 'stereo-lr'; // Default mode is stereo left-right
let isVideoLoaded = false;
let mouseDown = false;
let mouseX = 0, mouseY = 0;
let lon = 0, lat = 0;
let phi = 0, theta = 0;

// DOM elements
const container = document.getElementById('video-container');
const controls = document.getElementById('controls');
const playPauseBtn = document.getElementById('play-pause');
const progressBar = document.getElementById('progress');
const progressContainer = document.getElementById('progress-bar');
const timeDisplay = document.getElementById('time');
const volumeSlider = document.getElementById('volume-slider');
const loadingIndicator = document.getElementById('loading');
const dropArea = document.getElementById('drop-area');
const fileSelectBtn = document.getElementById('file-select-btn');

// Initialize the application
function init() {
  // Create Three.js scene
  scene = new THREE.Scene();
  
  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0.01);
  camera.layers.enable(1); // Enable default layer // Small offset to avoid rendering issues
  // Create camera

  
  // Create renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);
  
  // Create video element
  videoElement = document.createElement('video');
  videoElement.playsInline = true;
  videoElement.loop = true;
  videoElement.crossOrigin = 'anonymous';
  
  // Event listeners
  window.addEventListener('resize', onWindowResize);
  container.addEventListener('mousedown', onMouseDown);
  container.addEventListener('mousemove', onMouseMove);
  container.addEventListener('mouseup', onMouseUp);
  container.addEventListener('wheel', onMouseWheel);
  
  // Touch events for mobile
  container.addEventListener('touchstart', onTouchStart);
  container.addEventListener('touchmove', onTouchMove);
  container.addEventListener('touchend', onTouchEnd);
  
  // Video controls
  playPauseBtn.addEventListener('click', togglePlayPause);
  progressContainer.addEventListener('click', seekVideo);
  volumeSlider.addEventListener('input', updateVolume);
  
  // File drop handling
  dropArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropArea.classList.add('active');
  });
  
  dropArea.addEventListener('dragleave', () => {
    dropArea.classList.remove('active');
  });
  
  dropArea.addEventListener('drop', (e) => {
    e.preventDefault();
    dropArea.classList.remove('active');
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const file = e.dataTransfer.files[0];
      loadVideo(file.path);
    }
  });
  
  fileSelectBtn.addEventListener('click', () => {
    ipcRenderer.send('select-file');
  });
  
  // IPC events
  ipcRenderer.on('video-selected', (event, videoPath) => {
    loadVideo(videoPath);
  });
  
  ipcRenderer.on('reset-camera', () => {
    lon = 0;
    lat = 0;
  });
  
  ipcRenderer.on('set-mode', (event, mode) => {
    videoMode = mode;
    if (isVideoLoaded) {
      updateSphereUV();
    }
  });
  
  // Start animation loop
  animate();
}

// Load video file
function loadVideo(videoPath) {
  showLoading(true);
  
  if (videoElement.src) {
    videoElement.pause();
    videoElement.removeAttribute('src');
  }
  
  if (videoTexture) {
    videoTexture.dispose();
  }
  
  if (sphere) {
    scene.remove(sphere);
    sphere.geometry.dispose();
    sphere.material.dispose();
  }
  
  videoElement.src = videoPath.startsWith('http') ? videoPath : `file://${videoPath}`;
  videoElement.load();
  
  videoElement.onloadedmetadata = () => {
    createVideoSphere();
    
    videoElement.addEventListener('canplaythrough', () => {
      showLoading(false);
      showControls(true);
      showDropArea(false);
      
      videoElement.play()
        .then(() => {
          isPlaying = true;
          updatePlayPauseButton();
          isVideoLoaded = true;
        })
        .catch(error => {
          console.error('Error playing video:', error);
        });
    }, { once: true });
    
    videoElement.addEventListener('timeupdate', updateProgressBar);
    videoElement.addEventListener('ended', () => {
      isPlaying = false;
      updatePlayPauseButton();
    });
  };
  
  videoElement.onerror = () => {
    showLoading(false);
    showDropArea(true);
    alert('Error loading video. Please try another file.');
  };
}

// Create sphere with video texture
function createVideoSphere() {
  videoTexture = new THREE.VideoTexture(videoElement);
  videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.encoding = THREE.sRGBEncoding; // Add this line
  
  const geometry = new THREE.SphereGeometry(500, 120, 80);
  geometry.scale(-1, 1, 1); // Invert the sphere so we see the video on the inside
  
  const material = new THREE.MeshBasicMaterial({ map: videoTexture });
  
  sphere = new THREE.Mesh(geometry, material);
  scene.add(sphere);
  
  updateSphereUV();
}

// Update UV mapping based on video mode
function updateSphereUV() {
  if (!sphere) return;
  
  const geometry = sphere.geometry;
  const uv = geometry.attributes.uv;
  
  for (let i = 0; i < uv.count; i++) {
    let u = uv.getX(i);
    let v = uv.getY(i);
    
    switch (videoMode) {
      case 'mono':
        // Reset to full UV mapping
        u = uv.getX(i);
        v = uv.getY(i);
        break;
      case 'stereo-lr':
        // Left-right stereo
        u = u * 0.5 + (camera.layers.mask === 1 ? 0 : 0.5);
        break;
      case 'stereo-tb':
        // Top-bottom stereo
        v = v * 0.5 + (camera.layers.mask === 1 ? 0 : 0.5);
        break;
    }
    
    uv.setXY(i, u, v);
  }
  
  uv.needsUpdate = true;
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  // Update camera position based on mouse movement
  if (!mouseDown) {
    lon += 0.05;
  }
  
  lat = Math.max(-85, Math.min(85, lat));
  phi = THREE.MathUtils.degToRad(90 - lat);
  theta = THREE.MathUtils.degToRad(lon);
  
  const x = Math.sin(phi) * Math.cos(theta);
  const y = Math.cos(phi);
  const z = Math.sin(phi) * Math.sin(theta);
  
  camera.lookAt(new THREE.Vector3(x, y, z));
  
  renderer.render(scene, camera);
}

// Event handlers
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onMouseDown(event) {
  event.preventDefault();
  mouseDown = true;
  mouseX = event.clientX;
  mouseY = event.clientY;
}

function onMouseMove(event) {
  if (!mouseDown) return;
  
  const deltaX = event.clientX - mouseX;
  const deltaY = event.clientY - mouseY;
  
  mouseX = event.clientX;
  mouseY = event.clientY;
  
  lon -= deltaX * 0.2;
  lat += deltaY * 0.2;
}

function onMouseUp() {
  mouseDown = false;
}

function onMouseWheel(event) {
  const fov = camera.fov + event.deltaY * 0.05;
  camera.fov = THREE.MathUtils.clamp(fov, 30, 90);
  camera.updateProjectionMatrix();
}

function onTouchStart(event) {
  if (event.touches.length === 1) {
    event.preventDefault();
    mouseDown = true;
    mouseX = event.touches[0].pageX;
    mouseY = event.touches[0].pageY;
  }
}

function onTouchMove(event) {
  if (mouseDown && event.touches.length === 1) {
    event.preventDefault();
    
    const deltaX = event.touches[0].pageX - mouseX;
    const deltaY = event.touches[0].pageY - mouseY;
    
    mouseX = event.touches[0].pageX;
    mouseY = event.touches[0].pageY;
    
    lon -= deltaX * 0.2;
    lat += deltaY * 0.2;
  }
}

function onTouchEnd() {
  mouseDown = false;
}

// Video control functions
function togglePlayPause() {
  if (isVideoLoaded) {
    if (isPlaying) {
      videoElement.pause();
    } else {
      videoElement.play();
    }
    
    isPlaying = !isPlaying;
    updatePlayPauseButton();
  }
}

function updatePlayPauseButton() {
  playPauseBtn.classList.toggle('playing', isPlaying);
}

function updateProgressBar() {
  const currentTime = videoElement.currentTime;
  const duration = videoElement.duration;
  
  if (duration > 0) {
    const percentage = (currentTime / duration) * 100;
    progressBar.style.width = `${percentage}%`;
    
    const currentMinutes = Math.floor(currentTime / 60);
    const currentSeconds = Math.floor(currentTime % 60);
    const totalMinutes = Math.floor(duration / 60);
    const totalSeconds = Math.floor(duration % 60);
    
    timeDisplay.textContent = `${padTime(currentMinutes)}:${padTime(currentSeconds)} / ${padTime(totalMinutes)}:${padTime(totalSeconds)}`;
  }
}

function seekVideo(event) {
  if (!isVideoLoaded) return;
  
  const rect = progressContainer.getBoundingClientRect();
  const percentage = (event.clientX - rect.left) / rect.width;
  videoElement.currentTime = percentage * videoElement.duration;
}

function updateVolume() {
  videoElement.volume = volumeSlider.value;
}

function padTime(time) {
  return time.toString().padStart(2, '0');
}

// UI helper functions
function showLoading(show) {
  loadingIndicator.style.display = show ? 'flex' : 'none';
}

function showControls(show) {
  controls.style.display = show ? 'flex' : 'none';
}

function showDropArea(show) {
  dropArea.style.display = show ? 'flex' : 'none';
}

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', init);